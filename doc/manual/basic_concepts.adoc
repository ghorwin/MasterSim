:imagesdir: ./images
= Introduction and basic concepts

_MasterSim_ is a co-simulation master program that supports FMI co-simulation. If you are new to co-simulation in general, or not yet familiar with the Functional Mock-Up Interface (FMI), I suggest reading up a bit on the basics on the https://fmi-standard.org[fmi-standard.org] webpage.

Basically, _MasterSim_ couples different simulation models and exchanges data between simulation slaves at runtime. The following Figure illustrates the program organisation and the basic data flow.

.Data flow and file usage diagram
image::DataFlowDiagram.png[Data flow diagram,pdfwidth=80%]

== Program parts
_MasterSim_ consists of a two parts:

a. graphical user interface (GUI) and 
b. a command line simulator program _MasterSimulator_

The GUI makes it very easy to generate, adjust, modify simulation projects. A simulation project is stored in two files, the _MasterSim_ project file and the graphical representation file. The latter is optional and not needed for the simulation.

The simulation is executed by the command line program _MasterSimulator_, which reads the project file, imports referenced FMUs and run the simulation. The generated results, both from _MasterSimulator_ itself and possibly from slaves are then used by any post processing tool (like https://bauklimatik-dresden.de/postproc[PostProc 2]) to visualize and analize results.

The separation between user interface and actual simulator makes it very easy to use _MasterSim_ in a scripted environment, or for systematic variant analysis as described below in section <<_workflows,Workflows>>.

== Supported FMU types

- FMI for Co-Simulation version 1
- FMI for Co-Simulation version 2, including support for getting/setting states

No asynchronous FMU types supported.

On Linux and Mac, MasterSim is typically only built as 64-bit application. On Windows, MasterSim is available as 32-bit and 64-bit application.

[IMPORTANT]
====
For 32-bit FMUs use a 32-bit build, for 64-bit FMUs use a 64-Bit version. Mixed FMU platform types (32-Bit and 64-Bit) are not supported.
====

== Design Criteria/Key Features

- cross-platform: Windows, MacOS, Linux
- no dependency on externally installed libraries, all source included in release, especially no dependency on FMI support libraries (exception: standard C++, and the Qt 5 libraries); checking out source code and building it should be easy (also packaging for different platforms)
- complete master functionality wrapped in library _MasterSim_ usable by command line tools and GUI applications
- message handling wrapped to support GUI integration and log file support, no direct `printf()` or `std::cout` statements
- supports FMU debugging: can disable unzipping (persistant dll/so/dylib files), source access allows debugging runtime loading of shared libraries and attaching debuggers
- high-level C++ code (readible and maintainable)
- includes instrumentation to retrieve counters and timers for benchmarking performance of master algorithms and FMUs
- code tailored for master algorithm debugging - all variables in type-specific arrays for _easy analysis in debugger_

See chapter <<_features_assisting_in_fmu_development_and_debugging, Features assisting in FMU development and debugging>> for details about functionality that are particularly important for FMU developers and for debugging problems with the co-simulation.

== Terminology

The following terms are used in the manual and also in the naming of classes/variables:

[horizontal]
FMU:: describes the fmu archive including model description and shared libraries
slave/simulator:: describes a simulation model that is instantiated/created from an FMU; there can be several slaves instantiated by a single FMU, if the capability *canBeInstantiatedOnlyOncePerProcess* is set to true
master:: describes the overall simulation control framework that does all the administrative work
simulation scenario:: defines a set of slaves and their connections (data exchange), as well as other properties such as start and end time, algorithm options, output settings; alternatively called *system*
graph network:: another description for the topology of interconnected slaves
master algorithm:: describes the implementation of a mathematical algorithms that advances the coupled simulation in time; may include an iteration scheme
error control:: means local error check (step-by-step based), used for time step adjustment scheme
master time:: time of master simulation, starts with 0; unit is not strictly defined (needs to be common agreement between FMUs, typically in seconds, with exception of using file reader slaves, see section <<_csv_filereader_slaves,CSV FileReader Slaves>>).
current (master) time:: the time that the master state is at, changes *only* at end of successful `doStep()` or  `restoreState()` calls.

== Workflows

As with any other simulation models, most workflows involve a variant analysis. In the context of co-simulation, such variants are often created by modifying FMUs and their paramters. _MasterSim_ includes functionality to streamline such workflows.

[TIP]
====
Many workflows involve repeated execution of _MasterSim_ with little or no modifications in the project file. Sometimes it is very convenient to use the same project file and modify it, but specify a different working directory (where outputs are stored), so that the results of different variants can be compared +
(see `--working-dir` command line argument described in section <<_workingoutput_directory, Working/output directory>>).
====

=== Initial setup of simulation scenario

Straight forward procedure:

. import all FMUs and assign slave ID names
. (optional) specify parameter values for slaves
. (optional) define graphical representation of slaves
. connect output and input variables 
. set simulation parameters
. run simulation
. inspect results

=== Only published parameters of FMUs are modified

Extremely simple case and, if supported by FMUs, definitely best-practice. In _MasterSim_ only the value assigned to a published parameter needs to be changed (can be done also directly in the project file, e.g. with scripts) and the simulation can be repeated.

=== FMUs change internal behavior, but do not change interface

This is the most typical case. Here, the input and output variable names and types remain unchanged and also the published parameters remain the same. Yet, the internal behavior of the model changes due to adjustment of internal model behavior, after which the FMUs are exported. Since _MasterSim_ only references FMUs, in such cases the FMU files can simply be replaced and without any further changes the simulator can be started.

=== FMUs change parameters, but do not change inputs/outputs

In this situation, when a parameter has been configured in _MasterSim_ that no longer exists (or has been renamed), the respective definition must be changed in the project file or be removed in the user interface.

=== FMUs change interface

When an imported FMU changes part of its interface (e.g. input or output variables are modified), then this will be shown in the user interface by highlighting invalid connections. If only variable names were changed, you are best of by editing the project file and renaming the variable name there. Otherwise, simply remove the connection and reconnect. 

When the variable type changes of an input/output variable, so that an invalid connection is created (or the causality changes), then the user interface may not directly show the invalid connection. However, during initialization, the _MasterSimulator_ command line program will flag that error and abort.

== Master Algorithms

A _master algorithm_ is basically the mathematical procedure to advance the coupled simulation by one step forward. Such a co-simulation naster algorithm has a characteristic set of rules on how to retrieve values from one FMU, when and how these values are passed on to other FMUs, whether this procedure is repeated and the criteria for convergence of iterations.

_MasterSim_ implements several standard algorithms. A detailed discussion of the different algorithms and how the choice of algorithm and parameters affect results can be found in the following publication:

- Nicolai, A.: *Co-Simulations-Masteralgorithmen - Analyse und Details der Implementierung am Beispiel des Masterprogramms MASTERSIM*, http://nbn-resolving.de/urn:nbn:de:bsz:14-qucosa2-319735, in german


=== Common principles

All have some general properties in common.



The simulation time is expected to be in seconds in the user interface. That means, if you specify an end time point of `1 h`, the master will send 3600 as time in the last `doStep()` call. If you specify a start time different from 0, the master simulator will start its first communication interval at this time (the slave needs to process the `setupExperiment()` call correctly and initialize the slave to the start time point).


=== Gauss-Jacobi ===

=== Gauss-Seidel ===

=== Newton ===

== Time step adjustment

This flag is needed for certain FMUs, which include a test against surpassing the end simulation time. This is in some cases related to time series parameters, that only last until exactly the simulation end time. Another problem is also, that rounding errors can add to a very small overshooting of the end time point. Nevertheless, well-behaving FMUs should handle overstepping gracefully. Yet, to avoid an FMU error and abort of the simulation, _MasterSim_ can adjust the last communcation interval's size such, that exactly the end time of the simulation is given to the FMU. If this flag is enabled, the last interval's step size may be adjusted, even though time step adjustment is generally disabled by flag *(7)*.


== Error control and time step adjustment

[TIP]
====
If you use an adaptive step algorithm in _MasterSim_, you should set a minimim time step/fallback time step that is *larger* than your "small change step". Otherwise, MasterSim may try to resolve the dynamics of the step change by adjusting the time steps to extremely small values.
====




Initial Conditions
------------------------

Basically, consistent initial conditions can be obtained by repeatedly setting inputs and retrieving outputs of slaves **without** calling `doStep()` in between. Hence, the states of the slaves do not have to be stored and retrieved, so initial condition iteration is also possible with FMI v1.

The master algorithm implementations can be recycled, when the calls to the following functions

- `doStep()`
- `currentState()`   (only FMI2)
- `setState()` (only FMI2)

are disabled by a flag.

Unconnected inputs need to be set to their start-values only once. Also, parameters need to be set by the master only once *before* the initial condition iteration.

Convergence Test
--------------------------

For all iterative algorithms, convergence is found when:

- all integer values match
- all boolean values match
- all string values match
- the WRMS norm of all real values match

Weighted root mean square norm (WRMS-norm) is computed as follows:

~~~
#!code.cpp
	double norm = 0;
	for (unsigned i=0; i<m_realytNextIter.size(); ++i) {
		double diff = m_realytNextIter[i] - m_realytNext[i];
		double absValue = std::fabs(m_realytNextIter[i]);
		double weight = absValue*m_project.m_relTol + m_project.m_absTol;
		diff /= weight;
		norm += diff*diff;
	}

	norm = std::sqrt(norm);
~~~

Documentation of Algorithms and their Functionality
---------------------------------------------------------

There is a publication (in german) that shows how the different choices of the master algorithms will affect result and evaluation counts:

Nicolai, A.; 2018, *Co-Simulations-Masteralgorithmen - Analyse und Details der Implementierung am Beispiel des Masterprogramms MASTERSIM*, Qucosa, [doi-link (added soon, once available)](doi-link)

The paper can be downloaded from the MASTERSIM Webpage -> documentation section.

Meaningful Combinations of Algorithms
---------------------------------------------------------

See [wiki:MasterSimProjectFileFormat] for options to configure the following algorithmic combinations.

### 1. Gauss-Jacobi (non-iterating, no error test) ###

* works with FMI v1 and v2
* no iteration
* no error test
* fixed step size

Limitations on error and stability. Optionally supports parallelization (see performance tweaks discussion).

### 2. Gauss-Seidel (non-iterating, no error test) ###

* works with FMI v1 and v2
* no iteration
* no error test
* fixed step size

Limitations on error and stability. A bit better than Gauss-Jacobi.

### 3. Gauss-Seidel (non-iterating, with error test) ###

* works with FMI v2
* no iteration
* error test
* adaptive step size, step size is adjusted based on convergence rate

### 4. Gauss-Seidel (iterating, fixed step, with optional a priori error test) ###

* requires FMI v2
* uses iteration
* optional error test, failure to pass error test will stop the master
* fixed step size, failure to converge will stop the master

Fixing the time step allows performance comparison with other algorithms.

### 5. Gauss-Seidel (iterating with optional error test) ###

* requires FMI v2
* uses iteration
* optional error test, failure to pass error test will stop the master
* adaptive step size (reduction on convergence failure, and increase on fast convergence, reduction on error test failure)

Stable due to time step reduction, error control possible.

### 6. Newton (iterating with optional error test) ###

* requires FMI v2
* uses iteration
* optional error test
* adaptive step size (reduction on convergence failure, and increase on fast convergence, reduction on error test failure)

Stable due to time step reduction, error control possible. Convergence rate and success improved over Gauss-Seidel.

## FMU Requirements ##

Depending on the selected algorithmic options, FMU must have certain capabilities:

### Using time step adjustment ###

* FMU can handle variable time steps

### Using iteration ###

* FMU can be set back (FMI v2)

### Using Error Control with step size adaptation ###

* FMU can be set back (FMI v2)
* FMU can handle variable time steps



Master Algorithms
--------------------------

### Starting Conditions ###

All algorithms start with the following conditions:

* all slaves are at time level t
* output-variable cache of slaves are updated to time level t
* global variable vectors are updated to time level t

When iteration is enabled *and* step adjustment is enabled, the FMU slave states are expected to be stored already, otherwise they will be stored at the begin of an iterating algorithm. 

### Gauss-Jacobi ###
**Note:** MasterSim only implements the non-iterative Gauss-Jacobi algorithm because and two Gauss-Jacobi-Iterations correspond two non-iterative steps with half the step size - and the latter version will be even more accurate and stable. Therefore Gauss-Jacobi is implemented always without iteration, error checking and time step adjustment.

~~~
loop all cycles:
  
  loop all slaves in cycle:

    set inputs for slave using variables from time level t
    advance slave in time (doStep() and caching of outputs)
    sync cached outputs with variables vector for time level t+1

copy variables from time level t+1 to variables vector of time level t
~~~

### Gauss-Seidel Iterative ###

Whether iterative or non-iterative version is used, is determined by iteration limit (==1, no iteration).

Solves is the fixed-point iteration

     x* = S(x)

where `S(x)` is the result of the evaluation of all slaves and mapping of outputs to inputs.


~~~
copy variables from time level t to variables vector of time level t+1

loop all cycles:

  loop iteration < maxIterations:
  
    if iterating:
      copy variables from time level t+1 to backup vector (for convergence check)
      if iteration > 1:
        restoreSlaveStates()
        
    loop all slaves in cycle:

      set inputs for slave using variables from time level t+1 (partially updated from previous slaves)
      advance slave in time (doStep() and caching of outputs)
      sync cached outputs with variables vector for time level t+1

  if iterating and numSlaves > 1:
    doConvergenceTest()
    if success:
      break

copy variables from time level t+1 to variables vector of time level t
~~~

Specific features of Gauss-Seidel implementation:

- for cycles with one slave no iteration is done, so no rollback is needed
- if slaves report discontinous outputs (from state events/time events) Gauss-Seidel may not converge, if the outer time step reduction loop reduces the time step below a certain limit the algorithm falls back to *non iterative Gauss-Seidel*

### Newton ###
The Newton algorithm is always iterative. The algorithm employs a modified Newton method, where the Jacobian is updated only once at the begin of each step.

The root finding problem stems from the re-arranged fixed-point iteration:

    0 = x - S(x) = G(x)
    
with the Jacobian

    dG/dx = I - dS/dx

in the algorithm, each cycle is treated individually. Cycles with a single slave are not iterated. Cycles with no coupling variables (that means, not really a cycle) are not treated as Newton.

~~~



~~~

Time Step Adjustment Method
-------------------------------------------

Variable communication steps are implemented only for FMUs v2 with rollback capabilities.

Principle algorithm:

~~~
loop until t > tEnd:
  loop until converged and error test has passed:
    take step
    if not converged:
      reduce step and try again
    do error test
    if error too large:
      reduce step and try again
  
  estimate step size for next step
~~~

### Error Estimation ###

The error test is done with the step-doubling technique. First a step is computed (it has converged in case of iterative algorithm). The same step is then calculated again but with two steps of halved size, yielding a solution of higher order.
The difference between method orders is used to estimate the local truncation error. This is done in analogy to Backward Euler which has method order 1. Suppose you have solution yh as the solution with the original step and yh2 as solution with halved steps, the error is estimated by:

    error = 2 || yh - yh2 ||
    
Since we deal with vectors, a suitable norm (WRMS norm) is used to compute the scalars yh and yh2.


### Implementation ###

The error test is optional and done right after a solution has converged. In this case the new solution (for time point t + stepsize) is stored in temporary vectors xxxNext. 

The error test algorithm copies this solution to vectors xxxFirst. It then resets the slaves to time point t and computes two steps of size stepsize/2. If any of the steps fails to converge during this attempt, the step size is **not** adjusted but the error test is marked as failed (when the long step converges, the smaller ones must converge as well, unless something significant has happened in the middle of the long step).

### Rounding Error Considerations ###

When taking two steps of size h2 = h/2 rounding errors can lead to states ending up at time `2*h2 != h`.  Since at end of error test slaves are positioned at time `t + 2*h2` we recompute the actual long step size  `h = 2*h2` and store that as long step size.

## Improving Estimated Solution with Richardson Extrapolation ##

For the error test we have to take 3 communication steps instead of 1 for a single interval. This extra work can also be used to generate a better estimate for the solution by combining the solution of the single step with the dual step solution (of higher order). With the Richardson extrapolation both solution are combined to create a better estimate for the result.





---