:imagesdir: ./images
= Einführung und Grundbegriffe

_MasterSim_ ist ein Co-Simulations-Masterprogramm, welche die FMI-Co-Simulation unterstützt. Wenn die Co-Simulation für Sie etwas gänzlich Neues ist oder Sie mit dem funktionalen Mock-Up-Interface (FMI) noch nicht vertraut sind, empfehle ich Ihnen, zunächst ein wenig über die Grundlagen zu lesen, z. B. auf der https://fmi-standard.org[fmi-standard.org]-Web-Seite.

Grundsätzlich verbindet _MasterSim_ verschiedene Simulationsmodelle und tauscht Daten zwischen Simulation-Slaves während der Laufzeit aus. Die folgende Grafik illustriert die Programmfunktion und ihren elementaren Ablauf und Datenaustausch.

.Diagramm über den Datenfluss und Anwendungen
image::DataFlowDiagram.png[Data flow diagram,pdfwidth=80%]

== Die Teile des Programms
_MasterSim_ besteht aus zwei Teilen:

a. einer grafischen Benutzeroberfläche (_graphical user interface_ - GUI) und
b. dem Simulationsprogramm _MasterSimulator_ für die Befehlszeile

Die Oberfläche macht es sehr einfach, Simulations-Projekte zu erzeugen, anzupassen und abzuändern. Ein Simulations-Projekt wird in zwei Dateien gespeichert, dem _MasterSim_-Projekt und der grafischen Darstellung (Verknüpfungsschematik). Letzteres ist optional und nicht notwendig für die Simulation.

Die Simulation wird durch das Befehlszeilen-Programm  _MasterSimulator_ ausgeführt, welches Projekt-Dateien liest, referenzierte FMUs importiert und die Simulation durchführt. Die erzeugten Ergebnisse, sowohl von _MasterSimulator_ selbst als auch diejenigen der Slaves werden dann von weiterverarbeitenden Werkzeugen genutzt, um die Ergebnisse zu visualisieren und zu analysieren (z. B. mit https://bauklimatik-dresden.de/postproc[PostProc 2]).

Die Trennung zwischen der Benutzeroberfläche und dem aktuellen Simulator macht es sehr einfach, _MasterSim_ in einer geskripteten Umgebung oder für eine systematische Variantenuntersuchung zu nutzen, wie sie weiter unten im Abschnitt <<workflow,Arbeitsablauf>> beschrieben wird.

== Unterstützte FMU - Varianten

- FMI für die Co-Simulation in der Version 1
- FMI für die Co-Simulation in der Version 2, inklusive der Unterstützung für Zustandssicherung/-Rücksetzung (Serialisierungsfunktionen)

Es werden keine asynchronen FMU-Varianten unterstützt.

_MasterSim_ ist für Linux und MacOS als 64-Bit-Anwendung verfügbar. Für Windows ist  _MasterSim_ sowohl als 32-Bit als auch 64-Bit-Anwendung vorhanden.

[IMPORTANT]
====
Nutzen Sie für 32-Bit-FMUs eine 32-Bit-Version, für 64-Bit-FMUs eine mit 64 Bit. Gemischte FMU-Plattform-Typen (32 Bit und 64 Bit) werden nicht unterstützt.
====

== Entwicklungsziele/Schwerpunkte

- Betriebssystemübergreifend: Windows, MacOS, Linux
- keine Abhängigkeit von extern installierten Bibliotheken, alle Quelltexte sind im Repository enthalten (Ausnahme: Standard C++ Laufzeitbibliotheken und die Qt 5-Bibliothek), insbesondere gibt es keine Abhängigkeit von FMI-unterstützenden Bibliotheken; den Quelltext vom Repository zu holen und zu erstellen sollte leicht sein (ebenso das Verpacken und Veröffentlichen für andere Plattformen) 
- vollständige, in die _MasterSim_-Bibliothek eingebettete Master-Funktionalität, nutzbar über das Kommandozeilen-Werkzeug und die Oberfläche
- Meldungen/Ausgaben sind gekapselt, um GUI-Einbindung und Log-Dateien zu unterstützen, keine direkten `printf()`- oder `std::cout` -Ausgaben
- unterstützt FMU-Fehlerdiagnose: kann das Entpacken  deaktivieren (dauerhafte dll/so/dylib-Dateien), der Quelltextzugang erlaubt die Fehlersuche während des Ladens von gemeinsam genutzten Bibliotheken und angefügten Debuggern
- High-Level- C++-Code (lesbar und wartungsfreundlich) 
- enthält Instrumentierung und stellt Zähler und Zeitmessungen für den Leistungsvergleich von Master-Algorithmen und FMU bereit
- der Code ist angepasst für die Fehleranalyse des Master-Algorhitmus - alle Variablen sind typspezifisch für eine _einfache Analyse im Debugger_ in Datenfeldern gruppiert 

Für Details über Funktionen, die insbesondere für FMU-Entwickler und bei Problemen der Fehlerbeseitigung von Co-Simulationen wichtig sind, lesen Sie bitte das Kapitel <<fmu_dev_helpers, Assistenzfunktionen für FMU-Entwicklung und Fehlerbeseitigung>>.

=== Besondere Funktionen von _MasterSim_

Es gibt eine besondere Funktion in _MasterSim_, welche hilfreich für die Verwendung von FMUs ist, welche  eigene Ausgabedaten schreiben. _MasterSim_ erstellt für jede FMU Instanz/jeden Slave ein beschreibbares, _slave-spezifisches_ Ausgabeverzeichnis. Der Pfad zu diesem Verzeichnis setzt _MasterSim_ im Parameter `ResultsRootDir`. Falls ein Slave einen solchen Parameter definiert, erhält die FMU über den Parameter ein verlässliches, gültiges Verzeichnis zum Hineinschreiben seiner Daten (siehe auch Abschnitt <<dir_slaves, Verzeichnis 'Slaves'>>).

== Terminologie

Die folgenden Begriffe werden sowohl im Handbuch als auch in der Benennung von Klassen/Variablen genutzt:

[horizontal]
FMU:: beschreibt das FMU-Archiv inklusive der Modellbeschreibung und der Laufzeit-Bibliotheken
Slave/Simulator:: beschreibt ein Simulationsmodell, dass aus einer FMU erstellt(instanziiert) wird; dabei können mehrere Slaves durch eine einzige FMU erstellt werden, falls die Fähigkeit/Eigenschaft *canBeInstantiatedOnlyOncePerProcess* deaktiviert ist
Master:: beschreibt den gesamten Rahmen der Simulationskontrolle, der die generelle Verwaltungsarbeit übernimmt
Simulationsszenario:: definiert eine Reihe von Slaves und deren Verbindungen (Datenaustausch) ebenso wie weiteren Eigenschaften, wie z. B. Start- und Endzeit, algorithmische Optionen, Ausgabeeinstellungen; alternativ auch *System* genannt
Netzwerk-Graph:: eine andere Beschreibung für die räumliche Struktur miteinander verbundener Slaves
Masteralgorithmus:: beschreibt die Implementierung eines mathematischen Algorithmus, der die zeitliche gekoppelte Simulation beschreibt; kann ein Iterationsverfahren enthalten
Fehlerkontrolle:: bezeichnet die Prüfung eines lokale Fehlers (Schritt-basiert), genutzt für die Anpassung des Kommunikationsschritts
Masterzeit:: Zeitpunkt der Mastersimulation, startet mit 0; die Zeiteinheit ist nicht strikt definiert (es muss eine gemeinsame Festlegung zwischen FMUs geben, normalerweise werden Sekunden verwendet; Ausnahmen sind Datei-Lese-Slaves, siehe Abschnitt <<csv_filereader_slaves,CSV-FileReader-Slaves>>).
Gegenwärtige (Master-)Zeit:: Zeitpunkt des aktuellen Master-Zustands; ändert sich *ausschließlich* am Ende eines erfolgreichen `doStep()`- oder `restoreState()`- Aufrufs.

[[workflow]]
== Arbeitsabläufe

Wie bei anderen Simulationsmodellen beinhalten die meisten Arbeitsabläufe eine Variantenanlyse. Im Kontext der Co-Simulation werden solche Varianten häufig durch die Modifizierung von FMUs und ihrer Parameter erzeugt. _MasterSim_ enthält Funktionen, um diesen Arbeitsprozess zu optimieren.

[TIP]
====
Viele Arbeitsabläufe beinhalten mehrfache Ausführungen von _MasterSim_ mit nur kleinen oder gar keinen Modifikationen in der Projektdatei. Manchmal ist ist es sehr komfortabel, die selbe Projektdatei zu nutzen und zu verändern, aber ein anderes Arbeitsverzeichnis (in dem Ausgänge gespeichert werden) zu bestimmen, damit das Resultat verschiedener Varianten verglichen werden kann (siehe auch das `--working-dir`-Befehlszeilenargument, beschrieben in Abschnitt <<solver_working_dir, Arbeits-und Ausgangsverzeichnis>>).
====

=== Ersteinrichtung eines Simulationsszenarios

Das ist eine recht direkte Vorgehensweise:

. Importieren Sie alle FMUs und weisen Sie Slave-ID-Namen zu
. (optional) Legen Sie Parametermeterwerte für die Slaves fest
. (optional) Definieren Sie die grafische Darstellung der Slaves
. Verbinden Sie die Ausgangs- und Eingangsgrößen
. Legen Sie die Simulationsparameter fest
. Führen Sie eine Simulation durch
. Prüfen und Bewerten Sie die Ergebnisse

=== Nur veröffentlichte FMU-Parameter sind modifiziert

Dies ist ein sehr einfacher Fall und, wenn von FMUs unterstützt, durchaus eine praktikable Methode. In _MasterSim_ müssen nur die den veröffentlichten Parametern zugewiesenen Werte geändert werden (dies kann auch direkt in der Projekt-Datei getan werden, z. B. auch mit Skripten) und die Simulation kann wiederholt werden.

=== FMUs ändern das interne Verhalten, aber nicht die Schnittstelle

Dies ist einer der häufigsten Fälle. Hier bleiben die Namen der Eingangs- und Ausgangsgrößen unverändert (d.h. die FMU-Schnittstelle bleibt unverändert). Auch die publizierten Parameter bleiben gleich. Jedoch ändert sich das interne Verhalten aufgrund der Anpassung des internen Modellverhaltens, wonach die FMU nochmals exportiert wurde. Da _MasterSim_ nur noch auf FMUs Bezug nimmt, können FMU-Dateien in solchen Fällen einfach ersetzt und der Simulator ohne weitere Anpassungen gestartet werden.

=== FMUs ändern Parameter aber nicht die Ein- und Ausgangsgrößen

In dieser Situation, in der ein Parameter in _MasterSim_ konfiguriert worden ist, der nicht länger existiert (oder dessen Name geändert wurde), muss die entsprechende Definition in der Projekt-Datei geändert oder von der Benutzeroberfläche entfernt werden.

=== FMUs ändern die Schnittstelle

Wenn eine importierte FMU einen Teil ihrer Oberfläche ändert (z. B. sind Ein- oder Ausgangsgrößen modifiziert), dann wird dies in der Benutzeroberfläche durch Hervorhebung der falschen/nun fehlenden Verbindungen angezeigt.  Wenn nur Variablennamen verändert wurden, editieren Sie am besten die Projekt-Datei und benennen dort die Größenbezeichnung um. Ansonsten sollte man einfach die Verbindung entfernen und eine neue erzeugen.

Wenn sich der Variablentyp einer Eingangs-/Ausgangsgröße ändert, sodass eine ungültige Verbindung entsteht (oder die Kausalität geändert wird), dann zeigt die Benutzeroberfläche die ungültige Verbindung nicht unbedingt direkt an. Allerdings wird das Befehlszeilenprogramm des  _MasterSimulator_ den Fehler während der Initialisierung anzeigen und abbrechen. Auch hier ist empfehlenswert, die fehlerhafte Verbindung zu löschen und neu zu erstellen.

== Ein Überblick über den Simulations-Algorithmus

_MasterSim_ hat folgende zentrale Bausteine:

- Initialisierung (Lesen der Projekt-Datei, Extraktion von FMUs, Überprüfung ...)
- Anfangsbedingungen
- Korrekturschleife während der Laufzeit 
- Master-Algorithmus (d.h. er versucht Schritte durchzuführen)
- Fehleranalyse
- Ausgaben zu angeforderten Zeitpunkten schreiben 

Diese Bausteine werden nachfolgend näher erläutert.

== Initialisierung

Zu Beginn der aktuellen Simulation (das Befehlszeilenprogramm _MasterSimulator_, siehe Abschnitt <<command_line_arguments, Befehlszeilen-Argumente >> zu Details zum Simulationsstart) wird die Struktur des Arbeitsverzeichnisses erzeugt und das Schreiben der Log-Datei gestartet.

Danach wird die Projekt-Datei gelesen und alle referenzierten FMUs werden entpackt. Wenn Verweise auf CSV-Dateien auftauchen (siehe Abschnitt <<csv_filereader_slaves, CSV-FileReader-Slaves>>), werden diese Dateien eingelesen und für Kalkulationen vorbereitet.

[TIP]
====
Das Entpacken der FMU-Archive kann mit der Befehlszeilen-Option `--skip-unzip` (siehe Abschnitt <<skip_FMU_extraction, Modifikation/Fixierung des FMU-Inhalts>>) übersprungen werden.
====

Als erster Schritt der aktuellen Co-Sim-Initialisierung werden alle FMU-Slaves erzeugt (dynamische Bibliotheken werden geladen und Symbole importiert, danach wird `fmiInstantiateSlave()` oder `fmi2Instantiate()` aufgerufen (entsprechend für FMI 1.0 bzw. FMI 2.0-Slaves). Es folgt eine Zusammenstellung aller Austauschvariablen und das Erstellen einer Variablenzuordnung.

Treten Fehler während der Initialisierung auf, führt dies zu einem Abbruch des Simulators mit einer entsprechenden Fehlermeldung.

=== Anfangsbedingungen

Die erste Aufgabe des Simulators ist es, für alle Slaves konsistente Anfangswerte zu erhalten. Das ist bereits eine nicht-triviale Aufgabe und nicht in allen Fällen ist der Erfolg garantiert. Die einzige Prozedur, die sowohl für FMI 1 und FMI 2-Slaves zum Einsatz kommen kann, ist das  schrittweise Lesen und Setzen von Eingangs- und Ausgangsgrößen in allen Slaves. Dieses wird wiederholt, bis keine Änderungen mehr beobachtet werden.

Der Algorithmus in _MasterSim_ ist:

----
Schleife über alle Slaves:
  - setupExperiment() für den aktuellen Slave aufrufen
  - setzen aller Variablen der Kausalitäten INPUT oder PARAMETER auf ihre Standardwerte, wie sie in der modelDescription.xml gegeben sind
  - setzen aller Parameter auf die in der Projektdatei spezialisierten Werte (falls Werte zugewiesen wurden)

für FMI 2: in allen Slaves enterInitializationMode() aufrufen

Schreife mit max. 3 Wiederholungen:
  Schleife über alle Slaves:
    alle Ausgangsvariablen des aktuellen Slave abfragen und in der globalen Variablenzuordnung speichern
  Schleife über alle Slaves:
    setzen aller Eingangsvariablen auf Werte der globalen Variablenzuordnung

für FMI 2: in allen Slaves exitInitializationMode() aufrufen
----

Achtung: Der Berechnungsalgorithmus für die Anfangsbedingungen ist derzeit ein Gauss-Jacobi-Algorithmus und als solcher nicht übermäßig stabil oder effizient. 

[CAUTION]
====
Wenn Sie mehr als 3 Slaves in einer Sequenz mit direktem Durchgang von Ein- zu Ausgangsvariablen verbunden haben, z. B. wenn die Ausgangsvariablen mit den Eingangsvariablen via algebraischer Verbindungen verknüpft sind, werden die 3 Wiederholungen des Gauss-Jacobi-Algorithmus eventuell nicht genügen, um alle Slaves korrekt zu initialisieren.

Durch eine Uneindeutigkeit im aktuellen FMI-Standard wird von Co-Simulations-Slaves nicht gefordert, die Ergebnisvariablen immer dann zu aktualisieren, wenn sich Eingangsvariablen ändern. Die meisten FMUs aktualisieren ihre Ausgangswerte tatsächlich erst nach der Aufforderung `doStep()`. Daher ist es mit dem gegenwärtigen Standard nicht möglich, zwischen den direkten mathematischen Beziehungen von Aus- und Eingängen zu unterscheiden. Dies heißt eine Änderung der Ergebnisvariablen *ohne Aufruf* von `doStep()` und *nach einem Aufruf* von `doStep()`.

_MasterSim_ wählt hier die Funktionalität von FMI 1.0, d.h. keine Schleifen innerhalb einer Iteration nur um Ein- und Ausgänge zu synchronisieren. Dies erfolgt unter der Annahme, dass die Ausgangsgrößen sich nicht direkt ändern, sobald neue Eingangsvariablen gesetzt wurden (dies gilt für die meisten FMUs). Unter dieser Bedingung sind 3 Wiederholungen immer ausreichend.
====

=== Start- und Endzeit der Simulation

_MasterSim_ behandelt die Simulationszeit als gegeben in _Sekunden_. 
[TIP]
====
Wenn die gekoppelten FMUs eine unterschiedliche Zeiteinheit verwenden (d. h. Jahre), benutzen Sie einfach Sekunden auf der Benutzeroberfläche und der Projektdatei und interpretieren die Werte als Jahre.
====

Die Simulationszeit wird in der Benutzeroberfläche und der Projektdatei in Sekunden eingetragen (oder irgend einer anderen unterstützten Einheit, die in Sekunden umgewandelt werden kann). Während der Simulation werden alle erfassten Zeiten (Start- und Endzeit und die Zeitstufengrößen und Größenbegrenzung) zuerst in Sekunden umgewandelt und danach ohne irgend eine weitere Einheitenumrechnung benutzt.

Beispiel: Wenn Sie einen Endzeitpunkt auf '1 h' festlegen, wird der Master bis zur Simultionszeit '3600' laufen, welche dann als _Endzeitpunkt des Kommunikationsintervals_ im letzten `doStep()`-Aufruf gesendet wird. 

Das gesamte Simulationszeit-Intervall wird an die Slaves im `setupExperiment()`-Aufruf weitergegeben. Wenn Sie die Startzeit anders als mit 0 festlegen, wird der Master-Simulator sein erstes Kommunikationsintervall zu diesem Zeitpunkt starten (der Slave braucht dies, um den `setupExperiment()`-Aufruf korrekt zu verarbeiten und den Slave zum Startzeitpunkt zu initialisieren).

[WARNING]
====
Der korrekte Umgang mit der Startzeit ist wichtig für alle FMUs, die eine Form der Bilanzierung oder Integration durchführen.
====

Die Endzeit der Simulation wird zur FMU auch per `setupExperiment()`-Aufruf übermittelt (das Argument `stopTimeDefined` ist durch _MasterSim_ immer auf `fmiTrue` gesetzt).

== Anpassung der Kommunikationsschrittlängen

Sobald das Kommunikationsintervall abgeschlossen ist, geht der Simulator in den Zeitschrittsanpassungsschleife über. Wenn die Anpassung der Zeitschritte über die Eigenschaft *adjustStepSize* deaktiviert ist (siehe Abschnitt <<simulator_settings>>), wird der Schleifeninhalt nur einmal ausgeführt. Für FMI 1.0 Slaves oder FMI 2.0 Slaves ohne die Fähigkeit zur Speicherung/Wiederherstellung des Slave-Status, ist eine Wiederholung eines Schritts ebenfalls nicht möglich (tatsächlich löst das Abfragen eines Wiederholungs-Algorithmus für solche Slaves einen Fehler während der Initialisierung aus).

[[fig_timestep_adjustment]]
.Simulationsbeispiel bei dem sowohl Fehlerschätzerüberschreitungen als auch Konvergenzfehler eine drastische Veränderung des Kommunikationszeitschritts bedingen
image::timestep_adjustment.png[width=600,height=300]

Innerhalb des Schleife versucht der ausgewählte _Master-Algorithmus_ einen einzelnen Schritt mit der gegenwärtig vorgeschlagenen Zeitschrittgröße zu machen (für eine konstante Schrittmethode wird der *hStart*-Parameter genutzt). Der _Master-Algorithmus_ kann möglicherweise eine wiederholende Auswertung der Slaves beinhalten (siehe unten).

Für einen sich wiederholenden Master-Algorithmus ist es dabei möglich, dass die Methode nicht innerhalb des gegebenen Grenzen konvergiert (siehe Parameter *maxIterations*). 

=== Zeitschritt-Verringerung, wenn der Algorithmus nicht konvergiert

Wenn der Algorithmus nicht innerhalb des vorgegebenen Wiederholungslimits konvergiert, wird die Kommunikationsschrittlänge um den Faktor 5 reduziert:

  h_new = h/5

Der Faktor 5 ist so ausgewählt, dass die Zeitschrittgröße schnell reduziert werden kann. Zum Beispiel, wenn eine Unterbrechung auftritt (z. B. ausgelöst durch eine schrittweise Änderung diskreter Signale) muss der Simulator die Zeitschritte schnell auf einen niedrigen Wert reduzieren, um die Schrittänderung zu überspringen.

Die Schrittgröße ist dann vergleichbar mit den Schritten des niedrigeren Datenübertragungs-Limits (Parameter *hMin*). Dies ist notwendig, um zu verhindern, dass die Simulation in extrem langsamen Zeitschritten stecken bleibt. Falls die Schrittgröße unter den Wert von *hMin* reduziert werden müsste, *würde die Simulation abgebrochen*.

In manchen Fällen kann die Interaktion zwischen zwei Slaves das Konvergieren jedweder Master-Algorithmen verhindern (sogar beim Newton-Algorithmus). Dennoch kann in diesen Fällen der verbleibende Fehler unerheblich sein und die Simulation kann in kleinen Schritten langsam über die problematische Zeit hinweggehen und danach die Schritte vergrößern. In diesen Fällen können Sie den Parameter *hFallBackLimit* festlegen, welcher größer sein muss als *hMin*. Wenn 'h' auf einen Wert unter diese _zulässige_ Mitteilungs-Schrittgröße reduziert ist, wird der Master-Algorithmus erfolgreich zurückkehren, nachdem alle Wiederholungen ausgeführt worden sind. Demnach wird der Schritt als _sich angenähert_ behandelt und die Simulation geht zum nächsten Intervall weiter.

TODO: Fehler Original s.o. tiptoe; acceptable

Die oben angeführte Publikation illustriert das Verhalten der Simulation beim Benutzen der Parameter. 

=== Fehlerkontrolle und Zeitschritt-Regulierung

Wenn eine Fehlertestmethode (*ErrorControlMode*) festgelegt ist, folgt einem konvergierendem Schritt eine lokale Fehlersuche. Derzeit basiert diese Fehlerprüfung auf der Schritt-Verdopplungs-Technik und kann als solche nur eingesetzt werden, wenn die Slaves FMI-2.0-Setzung/-Erhaltung der Statusfunktion unterstützen.

Grundsätzlich läuft der Test folgendermaßen ab: 

-----
- Setzten Sie den Slave-Status zurück, um den Lauf des Kommunikationsintervalls zu starten.
- Nehmen Sie zwei Schritte (mit dem vollen Master-Algorithmus pro Schritt)
- Berechnen Sie Fehlerkriterien 1 und 2
- Setzen Sie den Status zurück zum Status nach dem ersten Master-Algorithmus
-----
[NOTE]
====
Also, der Fehlertest benötigt zwei weitere Durchgänge des _Master-Algorithmus_ per Datenübertragung. Für wiederholende Master-Algorithmen oder den Newton-Algorithmus kann der Aufwand für den Fehlertest erheblich sein.
====

Die mathematischen Formeln und detaillierte Berechnungen des Fehlertests sind in der folgenden Publikation dokumentiert:  

Nicolai, A.: _Co-Simulation-Test Case: Predator-Prey (Lotka-Volterra) System_ (siehe https://bauklimatik-dresden.de/mastersim/documentation.php[MasterSim Documentation Webpage]).

Die Fehlersuche nutzt die Parameter `relTol` und `absTol` um die akzeptable Differenz zwischen Voll- und Halbschritt einzugrenzen (oder deren Neigung). Abhängig von der lokalen Fehlerschätzung, existieren zwei Optionen:

- die lokale Fehlerschätzung ist klein genug und der Zeitschritt wird vergrößert, 
- die Fehlersuche scheitert; die Schrittgröße wird entfernt und die gesamte Datenübertragung wird wiederholt werden. 

[TIP]
====
Wenn Sie einen Fehlersuche-Algorithmus in _MasterSim_ benutzen, sollten Sie ein Zeitschrittlimit für den Rückzug setzen. Andernfalls könnte _MasterSim_ versuchen, die Dynamiken der Schrittänderung zu beseitigen, indem es die Zeitschritte auf extrem niedrige Werte justiert. 
====


== Master-Algorithmen

Ein _Master-Algorithmus_ ist grundsätzlich die mathematische Prozedur, um die gekoppelte Simulation einen Schritt voran zu bringen. Solch ein Co-Simulations-Master-Algorithmus verfügt über ein charakteristisches Set an Regeln, um Werte von einem FMU abzurufen, wann und wie diese Werte an andere FMUs überführt werden und die Kriterien des Konvergierens von Wiederholungen. 

_MasterSim_ führt mehrere Standard-Algorithmen durch. Eine detaillierte Diskussion über die unterschiedlichen Algorithmen und wie die Wahl von Algorithmen und Parametern Ergebnisse beeinflusst, kann in der folgenden Publikation nachgelesen werden: 

Nicolai, A.: _Co-Simulations-Masteralgorithmen - Analyse und Details der Implementierung am Beispiel des Masterprogramms MASTERSIM_, http://nbn-resolving.de/urn:nbn:de:bsz:14-qucosa2-319735 (in german)

=== Gauss-Jacobi

Basis-Algorithmus:

-----
alle Slaves sollen folgende Schritte durchlaufen:
wiederholen aller Ausgangswerte
  

alle Slaves sollen folgende Schritte durchlaufen:
  setzen aller Eingangswerte
  dem Slave sagen. einen Schritt zu tun
-----

Gauss-Jacobi ist ohne Wiederholung fertig ausgeführt. Wie in der Publikation gezeigt (siehe oben), ergibt es wirklich keinen Sinn, eine Wiederholung zu nutzen. 

[NOTE]
====
Anstatt einen Schritt zur Datenübertragung für 10 Sekunden zu nutzen und Gauss-Jacobi für 2 Wiederholungen zu nutzen, ist es effizienter Wiederholungen zu deaktivieren (festlegen von *maxIterations=1*) und die Größe der Datenübertragungsschritte auf 5 Sekunden zu begrenzen. Der Aufwand für die Simultion ist exakt der gleiche, jedoch läuft die Simulation akkurater ab (und stabiler) mit dem 5-sekündigem Datenübertragungsintervall.
====

=== Gauss-Seidel

Basis-Algorithmus:

-----
Wiederholungsschleife:
  Durchlaufstationen aller Slaves:
    setzen der Eingangswerte für Slaves aus der globalen Werteliste
    den Slave veranlassen, einen Schritt zu tun
    wiederherstellen des Ausgangs aus dem gegenwärtigen Slave
    Erneuern der globalen Variablenliste
  eine konvergierende Prüfung durchführen
-----

==== Zyklen

_MasterSim_ enthält eine Funktion, die die Rechenleistung reduziert, wenn viele FMUs involviert sind und nicht alle direkt miteinander verbunden sind. Die folgende Figur zeigt ein Simulationsszenario, in dem die Berechnung in Stufen ausgeführt werden kann.

.Zyklen in sich wiederholenden Algorithmen
image::algorithm_cycles.png[alt="Cycles in iterative algorithms"]

[horizontal]
(1):: Dieses FMU erzeugt nur Ausgänge und kann nur ein einziges Mal im Gauss-Seidel-Algorithmus untersucht werden.
(2):: Diese zwei FMUs tauschen Werte aus, sie sind in einem _Zyklus_. Wenn der Gauss-Seidel-Algorithmus mit aktivierter Wiederholung ausgeführt wird, brauchen nur diese beiden FMUs aktualisiert werden und sie müssen Werte austauschen, denn sie erfordern keinen Eingang von anderen FMUs (außer für das Erste, dessen Ausgangsvariablen sind bereits bekannt).
(3):: Die letzten beiden FMUs sind auch in einem Zyklus gekoppelt, aber nur miteinander. Sie werden in der letzten Phase/Zyklus wiederholt. Bis die Ergebnisse der anderen drei FMUs berechnet worden und bekannt sind, müssen wieder nur drei FMUs im Zyklus sein. 

TODO: Korrektur Original: relation

Die Anzahl an FMUs in einem Zyklus zu begrenzen, reduziert nicht nur den gesamten Aufwand, sondern berücksichtigt auch die Starre der Kopplung. In einem Zyklus können die FMUs nur lose miteinander verbunden sein und die Konvergenz ist mit 2 oder 3 Wiederholungen erreicht. In anderen Zyklen können die FMUs in einer nicht linearen Verbindung gekoppelt sein oder sensibler auf Änderungen der Eingangswerte reagieren (= starre Kopplung) und zehn oder mehr Wiederholungen können benötigt werden. Dieses, das Vereinzeln der Zyklen, kann die Rechenleistung bei der Gauss-Seidel signifikant reduzieren.

Jedes FMU kann einem Zyklus zugewiesen sein, welcher nummeriert ist (Beginn bei 0) und in der Reihenfolge der Zyklusnummer ausgeführt wird (siehe Simulatordefinition im Abschnitt <<_Simulator-Slave-Definitionen, Simulator-/Slave- Definitionen>>).

=== Newton

Basis-Algorithmus:

-----
Wiederholungsschleife:
  Berechnen Sie in der ersten Wiederholung die Newtonmatrix via Angleichung des  Differenzquotienten

  Lassen sie alle Slaves Folgendes durchlaufen:
    Legen Sie alle Eingangswerte fest
    Befehlen Sie dem Slave, einen Schritt zu machen
  
  Lassen alle Slaves Folgendes durchlaufen:
    Rufen Sie alle Ausgangswerte ab

  Lösen Sie das Gleichungssystem
  Berechnen Sie die Abweichung der Variablen
  
  Führen Sie einen Konvergenz-Test durch
-----

Zyklen werden genauso behandelt wie mit dem Gauss-Seidel.

NOTE: Für den Fall, dass nur ein einziger FMU innerhalb des Zyklus ist, wird der Newton-Master-Algorithmus dieses FMU nur einmal auswerten und die Ergebnisse als bereits konvergiert behandeln. Natürlich wird in diesem Fall keine Newton-Matrix benötigt und verfasst. Allerdings wird es in dem (seltenen) Fall, dass ein solches FMU seine Eingangswerte mit _seinen eigenen Ausgängen_ verbindet, vielleicht zu Problemen führen, bis die potentiell ungültigen FMU-Bedingungen akzeptiert werden.

== Ausgänge schreiben

Ausgänge werden nach jedem vollendeten Schritt geschrieben, aber nur, wenn die Zeitspanne seit dem letzten Ausgangs-Schreiben mindestens so lang ist wie im Parameter *hOutputMin* festgelegt.

TIP: Wenn Sie Ausgänge wirklich nach jedem internen Schritt haben wollen, setzten Sie *hOutputMin* auf 0.


---
